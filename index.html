<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SHIB Ads WebApp</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap'); 

        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:'Vazirmatn', Arial, Helvetica, sans-serif;overflow:hidden;background: #0d0c1d;}
        
        .app-screen {
            position: fixed;
            inset: 0;
            background: url('img.png') no-repeat center center;
            background-size: cover;
            transition: opacity .5s ease-in;
            display: flex;
            flex-direction: column;
            opacity: 0;
            pointer-events: none; 
            z-index: 10; 
        }
        .app-screen.visible {
            opacity: 1;
            pointer-events: auto;
            z-index: 20; 
        }

        /* Loading Screen - Replaced with animated "LOADING" letter sequence */
        .loading-screen {
            position: fixed;
            inset: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity .5s ease-out;
            background: url('img2.png') no-repeat center center;
            background-size: cover; /* use provided image */
        }
        .loading-screen.hidden{opacity:0;pointer-events:none}

        .loader {
          --ANIMATION-DELAY-MULTIPLIER: 70ms;
          padding: 0;
          margin: 0;
          display: flex;
          flex-direction: row;
          justify-content: center;
          align-items: center;
          overflow: hidden;
        }

        .loader span {
          padding: 0;
          margin: 0;
          letter-spacing: -5rem;
          transform: translateY(4rem);
          animation: hideAndSeek 1s alternate infinite cubic-bezier(0.86, 0, 0.07, 1);
        }

        .loader .l { animation-delay: calc(var(--ANIMATION-DELAY-MULTIPLIER) * 0); color:#ff3b3b; }
        .loader .o { animation-delay: calc(var(--ANIMATION-DELAY-MULTIPLIER) * 1); color:#ff8c00; }
        .loader .a { animation-delay: calc(var(--ANIMATION-DELAY-MULTIPLIER) * 2); color:#ffd700; }
        .loader .d { animation-delay: calc(var(--ANIMATION-DELAY-MULTIPLIER) * 3); color:#4caf50; }
        .loader .ispan { animation-delay: calc(var(--ANIMATION-DELAY-MULTIPLIER) * 4); color:#00bfff; }
        .loader .n { animation-delay: calc(var(--ANIMATION-DELAY-MULTIPLIER) * 5); color:#6a5acd; }
        .loader .g { animation-delay: calc(var(--ANIMATION-DELAY-MULTIPLIER) * 6); color:#ff1493; }

        .letter {
          width: fit-content;
          height: 3rem;
        }

        .i {
          margin-inline: 5px;
        }

        @keyframes hideAndSeek {
          0% {
            transform: translateY(4rem);
          }
          100% {
            transform: translateY(0rem);
          }
        }
        /* End of replaced loader styles */

        /* Main Screen */
        .main-screen{
            background-color: #f0f0f0; 
        }
        
        .main-content{flex:1;display:flex;justify-content:center;align-items:center}
        
        /* User Circle */
        .user-circle{
            position:absolute;top:10px;left:15px;width:60px;height:60px;border:2px dashed #ccc;
            border-radius:50%;display:flex;flex-direction:column;justify-content:center;
            align-items:center;cursor:pointer;transition:all .3s ease;z-index:100;overflow:hidden
        }
        .user-circle:hover{border-color:#4a90e2;background:rgba(74,144,226,.05)}
        .user-circle img{width:100%;height:100%;object-fit:cover;border-radius:50%;display:none}
        .user-circle .placeholder{color:#999;font-size:12px;text-align:center}
        
        .user-username{
            position: absolute;
            top: 70px;
            left: 10px;
            width: 70px;
            font-size:13px;color:#555;white-space:nowrap;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .user-id{
            position: absolute;
            top: 85px;
            left: 10px;
            width: 70px;
            font-size:11px;color:#888;white-space:nowrap;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .balance{position:absolute;top:20px;right:20px;background:#fff;border:1px solid #ff5a5a;border-radius:12px;padding:8px 12px;font-family:'Courier New',monospace;font-size:16px;color:#ff2a2a;text-shadow:0 0 2px #ffbbbb;letter-spacing:1px;z-index:101;box-shadow:0 4px 6px rgba(0,0,0,.05)}
        
        /* Shared Progress Containers */
        .progress-group-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 90%;
            max-width: 300px;
            z-index: 102;
        }
        .daily-progress-container, .spin-progress-container {
            background: #fff;
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,.1);
            text-align: center;
            border-left: 5px solid #4a90e2; 
        }
        .spin-progress-container {
            border-left: 5px solid #ff8c00; 
        }
        .daily-progress-text, .spin-progress-text {font-size:14px;color:#333;margin-bottom:4px; font-weight: bold;}
        .daily-progress-bar, .spin-progress-bar {width:100%;height:12px;background:rgba(0,0,0,.1);border-radius:10px;overflow:hidden;margin-top:6px}
        .daily-progress-fill {height:100%;background:linear-gradient(90deg,#00f2fe,#4facfe);border-radius:10px;width:0%;transition:width .4s ease}
        .spin-progress-fill {height:100%;background:linear-gradient(90deg,#ff8c00, #ff4500);border-radius:10px;width:0%;transition:width .4s ease}

        /* Button Adjustments - Equal width for 5 buttons */
        .button-container{
            position:absolute;bottom:40px;left:50%;transform:translateX(-50%);
            display:grid; /* Change to grid for better control */
            grid-template-columns: repeat(5, 1fr); /* 5 equal columns (UPDATED) */
            gap: 8px; /* Slightly reduced gap */
            background:rgba(240,240,240,.9);padding:10px 10px; /* Reduced padding */
            border-radius:20px;box-shadow:0 4px 15px rgba(0,0,0,.1);backdrop-filter:blur(10px);
            width: 95%; /* Increased width for more space */
            max-width: 450px;
        }
        .nav-button{
            position:relative;background:linear-gradient(145deg,#4a90e2,#357abd);color:#fff;border:none;padding:10px 0; /* Adjust padding for height control */
            border-radius:10px;font-size:11px; /* Reduced font size for better fit */
            font-weight:bold;cursor:pointer;transition:all .1s ease;
            flex-grow: 1;
            min-width: auto;
            text-transform:uppercase;letter-spacing:.5px;box-shadow:0 5px 0 #2c5aa0,0 8px 12px rgba(0,0,0,.15);transform:translateY(0);
            text-align: center;
            line-height: 1; /* Ensure text fits */
        }
        .nav-button:hover{transform:translateY(-1px);box-shadow:0 6px 0 #2c5aa0,0 10px 15px rgba(0,0,0,.2)}
        .nav-button:active{transform:translateY(2px);box-shadow:0 3px 0 #2c5aa0,0 5px 8px rgba(0,0,0,.15)}
        .nav-button span{display:block;text-shadow:0 1px 2px rgba(0,0,0,.3)}

        .nav-button.task-btn{
            background:linear-gradient(145deg,#ffc107,#ff9800);
            box-shadow:0 5px 0 #cc9a00,0 8px 12px rgba(0,0,0,.15);
        }
        .nav-button.task-btn:hover{box-shadow:0 6px 0 #cc9a00,0 10px 15px rgba(0,0,0,.2)}
        .nav-button.task-btn:active{box-shadow:0 3px 0 #cc9a00,0 5px 8px rgba(0,0,0,.15)}

        /* NEW Style for Withdraw Nav Button */
        .nav-button.withdraw-btn-nav{
            background:linear-gradient(145deg,#ff2a2a,#cc2121);
            box-shadow:0 5px 0 #991919,0 8px 12px rgba(0,0,0,.15);
        }
        .nav-button.withdraw-btn-nav:hover{box-shadow:0 6px 0 #991919,0 10px 15px rgba(0,0,0,.2)}
        .nav-button.withdraw-btn-nav:active{box-shadow:0 3px 0 #991919,0 5px 8px rgba(0,0,0,.15)}

        /* ===== Task Screen - REDESIGNED STYLING ===== */
        .task-screen{
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content: flex-start; 
            padding-top: 50px; 
            padding-bottom: 120px; 
            overflow-y: auto;
            background: #ffffed; /* Light, paper-like background */
        }
        .task-header{ 
            text-align: center;
            margin-bottom: 30px;
            width: 90%;
            max-width: 350px;
        }
        .task-title{ 
             font-family: 'Vazirmatn', sans-serif; 
             font-size:24px; 
             color:#333; /* Dark pencil color */
             font-weight:700; 
             text-shadow: 1px 1px 0 #fff; 
             border-bottom: 2px dashed #a0a0a0;
             padding-bottom: 10px;
        }
        
        /* New Task Card Style based on user's input (Paper Style) */
        .task-content-container {
            width: 100%;
            padding: 0 10px;
            max-width: 400px;
        }

        .task-item-card {
            background:#ffffff; /* White card */
            margin:10px 0;
            padding:18px;
            border-radius:10px;
            display:flex;
            justify-content:space-between;
            align-items:center;
            border: 1px solid #ddd; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .task-text-info {
            color: #555; /* Slightly lighter text */
            font-size: 16px;
            font-weight: 500;
        }

        /* Button style from user's input (Pencil Style Action Button) */
        .task-action-btn-new {
            background:linear-gradient(145deg, #ffc107, #ff9800);
            border:1px solid #cc9a00;
            color:#fff;
            padding:10px 20px;
            border-radius:8px;
            cursor:pointer;
            font-size:1em;
            font-weight: bold;
            min-width: 90px; 
            transition: all 0.1s ease;
            box-shadow: 0 4px 0 #cc9a00;
            text-transform: uppercase;
        }
        .task-action-btn-new:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 0 #cc9a00;
        }
        .task-action-btn-new:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #cc9a00;
        }
        .task-action-btn-new:disabled {
            background:#ccc;
            border-color:#aaa;
            color:#666;
            cursor:not-allowed;
            box-shadow: 0 4px 0 #aaa;
            transform: translateY(0);
        }
        
        .task-action-btn-new.completed {
            background:linear-gradient(145deg, #28a745, #1e7e34); /* Green for completed */
            border-color: #1c6d32;
            color: #fff;
            cursor: default;
            box-shadow: 0 4px 0 #1c6d32;
        }
        .task-action-btn-new.completed:disabled {
             background:linear-gradient(145deg, #1e7e34, #1c6d32); /* Darker green when disabled (after completion) */
             color: #ccc;
             box-shadow: 0 4px 0 #1c6d32;
        }
        
        /* Task Note style - REMOVED */
        .task-screen .note{ display: none; }

        /* Back Button Style - FIXED at bottom */
        .task-back-btn {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background:linear-gradient(145deg, #6c757d, #5a6268);
            color:#fff;border:none;padding:15px 40px; /* Larger padding */
            border-radius:12px;
            font-size:16px;
            font-weight:bold;
            cursor:pointer;
            box-shadow:0 6px 0 #4e555b; /* Larger shadow */
            transition:all .1s ease;
            width: 90%;
            max-width: 350px;
            z-index: 1000; /* Ensure it's above other elements */
        }
        .task-back-btn:active{transform:translateY(3px) translateX(-50%);box-shadow:0 3px 0 #4e555b}
        
        /* ===== Spin Screen ===== */
        .spin-screen{
            display:flex;flex-direction:column;align-items:center;justify-content:center;
            transition:opacity .3s ease;
        }
        #wheelBox{position:relative;margin-bottom:25px}
        #wheelCanvas{
            border-radius:50%;
            /* Enhanced 3D Look */
            box-shadow:0 0 0 10px #eee, 0 15px 35px rgba(0,0,0,0.4); 
            background-color: #fefefe; 
            border: 2px solid #ccc; 
            transform-origin: center center;
            transition: transform 4s cubic-bezier(0.22,0,0.2,1);
            will-change: transform;
        }
        /* Extra visual effect while spinning (glow) */
        #wheelCanvas.spinning {
            box-shadow: 0 0 40px rgba(255, 102, 136, 0.25), 0 15px 35px rgba(0,0,0,0.4);
            filter: drop-shadow(0 10px 20px rgba(0,0,0,0.25));
        }
        .arrow{
            position:absolute;top:-16px;left:50%;transform:translateX(-50%);
            width:0;height:0;border-left:18px solid transparent;border-right:18px solid transparent;
            border-top:28px solid #ff3366;filter:drop-shadow(0 3px 2px rgba(0,0,0,.3));z-index:10;
        }
        .spin-btn{background:#ff3366;color:#fff;border:none;padding:12px 35px;border-radius:30px;font-size:16px;font-weight:bold;cursor:pointer;box-shadow:0 6px 0 #cc2950;transition:all .1s ease}
        .spin-btn:active{transform:translateY(3px);box-shadow:0 3px 0 #cc2950}
        .spin-result{margin-top:18px;font-size:18px;color:#333}
        .spin-back{margin-top:25px;background:#6c757d;color:#fff;border:none;padding:10px 25px;border-radius:8px;font-size:15px;font-weight:bold;cursor:pointer;box-shadow:0 4px 0 #5a6268}
        .spin-back:active{transform:translateY(2px);box-shadow:0 2px 0 #5a6268}

        /* ===== Withdraw Screen - (No changes needed) ===== */
        .withdraw-screen{
            display:flex;flex-direction:column;align-items:center;padding:20px 20px;
            transition:opacity .3s ease;
            overflow-y: auto;
        }
        .withdraw-header{
            text-align: center;
            margin-bottom: 25px;
            width: 100%;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 15px;
        }
        .withdraw-title{
            font-size:28px;color:#ff2a2a;font-weight:700; text-shadow: 0 1px 1px rgba(0,0,0,.1);
        }
        .current-balance-info{
            font-size: 16px;
            color: #555;
            margin-top: 10px;
            font-weight: bold;
        }
        .input-form-container {
            width: 100%;
            max-width: 400px;
            background: #fff;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 6px 20px rgba(0,0,0,.1);
            border: 1px solid #ddd;
            margin-bottom: 20px;
        }
        .input-group{
            width:100%;margin-bottom:15px;
        }
        .input-group label{display:block;margin-bottom:8px;font-size:14px;color:#555;font-weight:600;}
        .input-group input{width:100%;padding:12px 15px;border:1px solid #ddd;border-radius:10px;font-size:16px;transition:border-color .3s ease, box-shadow .3s ease;outline:none;}
        .input-group input:focus{border-color:#ff8c00;box-shadow:0 0 0 3px rgba(255,140,0,0.2);}
        .withdraw-buttons{display:flex;gap:15px;margin-top:20px;justify-content: center;}
        .withdraw-btn{
            background:linear-gradient(145deg, #28a745, #1e7e34);
            color:#fff;border:none;padding:12px 30px;border-radius:10px;font-size:16px;font-weight:bold;cursor:pointer;
            box-shadow:0 5px 0 #1c6d32;transition:all .1s ease;
            width: 100%;
        }
        .withdraw-btn:active{transform:translateY(3px);box-shadow:0 2px 0 #1c6d32}
        .back-btn{
            background:linear-gradient(145deg, #6c757d, #5a6268);
            color:#fff;border:none;padding:12px 30px;border-radius:10px;font-size:16px;font-weight:bold;cursor:pointer;
            box-shadow:0 5px 0 #4e555b;transition:all .1s ease;
        }
        .back-btn:active{transform:translateY(3px);box-shadow:0 2px 0 #4e555b}
        .note{margin-top:15px;font-size:13px;color:#777;max-width:400px;text-align:center;background:rgba(255,140,0,0.1);padding:10px;border-radius:10px;border-left: 5px solid #ff8c00;}

        /* Withdrawal History Table */
        .history-section{
            width: 100%;
            max-width: 400px;
            margin-top: 30px;
            padding: 20px 0;
            border-top: 1px solid #eee;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 15px;
        }
        .history-title{
            font-size: 20px;
            color: #333;
            margin-bottom: 15px;
            font-weight: 700;
            text-align: center;
        }
        .history-table{
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        .history-table th, .history-table td{
            padding: 10px;
            border-bottom: 1px solid #eee;
            text-align: left;
        }
        .history-table th{
            background-color: #f0f4f8;
            color: #4a90e2;
            font-weight: 700;
        }
        .history-table tr:last-child td{
            border-bottom: none;
        }
        .status-pending{color: #ff8c00; font-weight: bold;}
        .status-completed{color: #28a745; font-weight: bold;}
        .no-records{text-align: center; color: #999; padding: 20px;}
        
        /* ===== Invite Screen - (No changes needed) ===== */
        .invite-screen{
            display:flex;flex-direction:column;align-items:center;padding:20px 20px;
            transition:opacity .3s ease;
            overflow-y: auto;
        }
        .invite-header{ 
            text-align: center;
            margin-bottom: 25px;
            width: 100%;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 15px;
        }
        .invite-title{ 
             font-size:28px;color:#4a90e2;font-weight:700; text-shadow: 0 1px 1px rgba(0,0,0,.1);
        }
        .referrals-count-info{
            font-size: 18px;
            color: #333;
            margin-top: 15px;
            font-weight: bold;
            padding: 10px 15px;
            background: #e6f0ff;
            border-radius: 10px;
            border: 1px solid #cce0ff;
            box-shadow: 0 2px 5px rgba(0,0,0,.05);
            width: 100%;
        }
        .invite-buttons{
            width: 100%;
            margin-top: 15px;
        }
        .copy-link-btn{
            background:linear-gradient(145deg, #00bfff, #0077b3);
            color:#fff;border:none;padding:12px 30px;border-radius:10px;font-size:16px;font-weight:bold;cursor:pointer;
            box-shadow:0 5px 0 #005a8d;transition:all .1s ease;
            width: 100%; 
        }
        .copy-link-btn:active{transform:translateY(3px);box-shadow:0 2px 0 #005a8d}
        #referralLinkInput{
            text-align: center;
            cursor: pointer;
            font-weight: 500;
            color: #4a90e2;
            background: #f8f8f8;
            word-break: break-all;
            white-space: normal;
        }
        
        /* Custom Alert Overlay - (No changes needed) */
        .custom-alert-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            z-index: 99999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .custom-alert-overlay.visible {
            display: flex;
            opacity: 1;
        }

        /* Custom Alert Box - 3D Pencil Style - SLIGHTLY SMALLER - (No changes needed) */
        .custom-alert-box {
            width: 90%;
            max-width: 280px; /* Smaller max width */
            background: #ffffed; /* Off-white paper background */
            border-radius: 15px;
            padding: 20px; /* Reduced padding */
            text-align: center;
            box-shadow: 
                0 8px 15px rgba(0, 0, 0, 0.3), /* Base shadow */
                inset 0 0 10px rgba(0, 0, 0, 0.05); /* Inner light effect */
            border: 3px solid #6b4d32; /* Pencil/Wood border */
            transform: perspective(600px) rotateX(0deg) scale(0.9);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* Spring effect */
        }
        .custom-alert-overlay.visible .custom-alert-box {
            transform: perspective(600px) rotateX(0deg) scale(1);
        }

        .alert-title {
            font-family: 'Vazirmatn', sans-serif;
            font-size: 20px; /* Slightly smaller title */
            font-weight: 700;
            color: #4CAF50; 
            margin-bottom: 8px; /* Reduced margin */
            text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.1); 
            letter-spacing: 0.5px;
        }

        .alert-message {
            font-family: 'Vazirmatn', sans-serif;
            font-size: 13px; /* Slightly smaller message */
            color: #333; 
            margin-bottom: 18px; /* Reduced margin */
            white-space: pre-wrap; 
        }

        .alert-icon {
            font-size: 35px; /* Slightly smaller icon */
            margin-bottom: 12px;
        }
        .alert-icon::before {
            content: '‚≠ê';
        }

        .alert-close-btn {
            background: #6b4d32; 
            color: #fff;
            border: none;
            padding: 9px 18px; /* Slightly smaller button */
            border-radius: 8px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 0 #543b27;
            transition: all 0.1s ease;
        }
        .alert-close-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #543b27;
        }

        /* Specific styles for Success */
        .custom-alert-box.success .alert-title { color: #28a745; }
        .custom-alert-box.success .alert-icon::before { content: 'üéÆ'; }

        /* Specific styles for Error/Warning */
        .custom-alert-box.error .alert-title { color: #dc3545; }
        .custom-alert-box.error .alert-icon::before { content: 'üîî'; }

        /* Specific styles for Warning/Info - Using Yellow/Brown for Pencil/Paper Theme */
        .custom-alert-box.warning .alert-title { color: #8B4513; } /* Brown */
        .custom-alert-box.warning .alert-icon::before { content: '‚úçÔ∏è'; } /* Pencil/Writing Icon */

        /* ===== Task Link Progress (NEW, COMPACT) ===== */
        .task-link-container {
            width: 100%;
            max-width: 360px;
            background: #fff;
            padding: 8px;
            border-radius: 10px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.06);
            border: 1px solid #e6e6e6;
            margin-bottom: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: stretch;
            font-size: 13px;
        }
        .task-link-title {
            font-size: 14px;
            color: #333;
            font-weight: 700;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .task-link-progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(0,0,0,0.06);
            border-radius: 8px;
            overflow: hidden;
        }
        .task-link-progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg,#ff9a00,#ff5a5a);
            border-radius: 8px;
            transition: width .4s ease;
        }

        /* 3D push button style for task link - smaller */
        .task-link-button {
            margin-top: 6px;
            align-self: center;
            background: linear-gradient(145deg,#ff7a7a,#ff3b3b);
            color: #fff;
            border: none;
            padding: 8px 14px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 6px 0 #b02323, 0 12px 30px rgba(0,0,0,0.12);
            transform: translateY(0);
            transition: all .12s ease;
            letter-spacing: 0.4px;
            text-transform: none;
        }
        .task-link-button:active {
            transform: translateY(4px);
            box-shadow: 0 4px 0 #b02323, 0 10px 25px rgba(0,0,0,0.10);
        }
        .task-link-button[disabled] {
            background: #ddd;
            color: #888;
            box-shadow: none;
            cursor: not-allowed;
            transform: none;
        }

        /* small helper text removed to keep it minimal as requested */
        .task-link-small {
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        .no-channel-tasks {
            margin-top: 12px;
            font-size: 13px;
            color: #666;
            text-align: center;
            background: rgba(255,255,255,0.6);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(0,0,0,0.04);
        }

    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
      <div class="loader">
        <span class="l">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 11 18" height="18" width="11" class="letter">
            <path fill="currentColor" d="M0.28 16.14V0.94L3.7 0.64L5.7 1.64V12.3L8.5 12.06L10.5 13.06V16.44L2.28 17.14L0.28 16.14ZM3.5 12.7V0.859999L0.48 1.12V15.94L8.3 15.26V12.28L3.5 12.7Z"/>
          </svg>
        </span>
        <span class="o">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 16 18" height="18" width="16" class="letter">
            <path fill="currentColor" d="M8.94 17.24C8.84667 17.2533 8.74667 17.26 8.64 17.26C8.54667 17.26 8.45333 17.26 8.36 17.26C7.66667 17.26 7.02667 17.16 6.44 16.96C5.86667 16.7733 5.30667 16.5533 4.76 16.3C3.33333 15.5933 2.28667 14.6 1.62 13.32C0.966667 12.0267 0.64 10.4933 0.64 8.72C0.64 7.68 0.766667 6.67333 1.02 5.7C1.28667 4.71333 1.68 3.82667 2.2 3.04C2.72 2.24 3.36667 1.58667 4.14 1.08C4.92667 0.573332 5.84667 0.273333 6.9 0.18C7.00667 0.166666 7.10667 0.159999 7.2 0.159999C7.29333 0.159999 7.38667 0.159999 7.48 0.159999C8.14667 0.159999 8.74 0.246666 9.26 0.419999C9.78 0.579999 10.3067 0.766666 10.84 0.979999C11.8 1.36667 12.6 1.94 13.24 2.7C13.88 3.46 14.36 4.35333 14.68 5.38C15 6.39333 15.16 7.48 15.16 8.64C15.16 9.72 15.0333 10.7533 14.78 11.74C14.5267 12.7267 14.14 13.62 13.62 14.42C13.1133 15.2067 12.4667 15.8467 11.68 16.34C10.9067 16.8467 9.99333 17.1467 8.94 17.24ZM6.92 16.04C7.94667 15.96 8.84 15.68 9.6 15.2C10.36 14.7067 10.9867 14.0733 11.48 13.3C11.9733 12.5133 12.34 11.64 12.58 10.68C12.8333 9.70667 12.96 8.69333 12.96 7.64C12.96 6.68 12.8467 5.76667 12.62 4.9C12.4067 4.02 12.0733 3.24 11.62 2.56C11.1667 1.88 10.5933 1.34667 9.9 0.959999C9.22 0.559999 8.41333 0.359999 7.48 0.359999C7.38667 0.359999 7.29333 0.359999 7.2 0.359999C7.12 0.359999 7.02667 0.366666 6.92 0.38C5.89333 0.473333 5.0 0.766666 4.24 1.26C3.48 1.74 2.84667 2.37333 2.34 3.16C1.83333 3.93333 1.45333 4.8 1.2 5.76C0.96 6.70667 0.84 7.69333 0.84 8.72C0.84 9.72 0.953333 10.6667 1.18 11.56C1.40667 12.44 1.74667 13.22 2.2 13.9C2.65333 14.5667 3.22667 15.0933 3.92 15.48C4.61333 15.8667 5.42 16.06 6.34 16.06C6.44667 16.06 6.54667 16.06 6.64 16.06C6.73333 16.06 6.82667 16.0533 6.92 16.04ZM6.92 12.94C6.86667 12.94 6.81333 12.9467 6.76 12.96C6.72 12.96 6.67333 12.96 6.62 12.96C5.82 12.96 5.18667 12.6133 4.72 11.92C4.26667 11.2267 4.04 10.0667 4.04 8.44C4.04 7.28 4.16667 6.34667 4.42 5.64C4.67333 4.93333 5.02 4.41333 5.46 4.08C5.9 3.73333 6.38667 3.54 6.92 3.5C6.97333 3.5 7.02667 3.5 7.08 3.5C7.13333 3.48667 7.18667 3.48 7.24 3.48C8.02667 3.48 8.64 3.82 9.08 4.5C9.52 5.16667 9.74 6.31333 9.74 7.94C9.74 9.67333 9.47333 10.9267 8.94 11.7C8.42 12.46 7.74667 12.8733 6.92 12.94ZM6.86 12.74C7.64667 12.6733 8.28667 12.2733 8.78 11.54C9.28667 10.8067 9.54 9.60667 9.54 7.94C9.54 7.18 9.49333 6.53333 9.4 6C9.30667 5.46667 9.16667 5.03333 8.98 4.7C8.91333 4.68667 8.84667 4.68 8.78 4.68C8.71333 4.66667 8.64667 4.66 8.58 4.66C7.79333 4.66 7.20667 5.07333 6.82 5.9C6.43333 6.71333 6.24 7.89333 6.24 9.44C6.24 10.2133 6.29333 10.8733 6.4 11.42C6.50667 11.9533 6.66 12.3933 6.86 12.74Z"/>
          </svg>
        </span>
        <span class="a">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 15 18" height="18" width="15" class="letter">
            <path fill="currentColor" d="M9.28 15.76L8.54 13.38L6.96 13.52L5.98 17.02L2.58 17.32L0.58 16.32L4.96 0.699999L8.26 0.419999L10.26 1.42L14.72 16.48L11.28 16.76L9.28 15.76ZM5.12 0.899999L0.88 16.08L3.8 15.84L4.8 12.34L8.36 12.02L9.42 15.56L12.44 15.3L8.1 0.64L5.12 0.899999ZM5.5 9.42C5.75333 8.59333 5.96 7.80667 6.12 7.06C6.29333 6.31333 6.44 5.56667 6.56 4.82H6.64C6.74667 5.55333 6.88 6.27333 7.04 6.98C7.21333 7.67333 7.42 8.42 7.66 9.22L5.5 9.42Z"/>
          </svg>
        </span>
        <span class="d">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 18" height="18" width="14" class="letter">
            <path fill="currentColor" d="M0.28 16.24V1.04L4.44 0.679999C4.61333 0.666666 4.78 0.66 4.94 0.66C5.1 0.646666 5.24667 0.64 5.38 0.64C6.11333 0.64 6.76667 0.726666 7.34 0.899999C7.92667 1.07333 8.56667 1.32667 9.26 1.66C10.1933 2.08667 10.9533 2.61333 11.54 3.24C12.1267 3.85333 12.56 4.61333 12.84 5.52C13.12 6.41333 13.26 7.50667 13.26 8.8C13.26 10.4933 12.9733 11.92 12.4 13.08C11.84 14.24 11.0667 15.1333 10.08 15.76C9.09333 16.3733 7.95333 16.74 6.66 16.86L2.28 17.24L0.28 16.24ZM4.64 15.68C5.89333 15.5733 7 15.2133 7.96 14.6C8.93333 13.9867 9.69333 13.1133 10.24 11.98C10.7867 10.8467 11.06 9.45333 11.06 7.8C11.06 5.53333 10.5733 3.80667 9.6 2.62C8.64 1.43333 7.21333 0.84 5.32 0.84C5.18667 0.84 5.04667 0.846666 4.9 0.859999C4.75333 0.859999 4.60667 0.866666 4.46 0.879999L0.48 1.22V16.02L4.64 15.68ZM3.5 3.9L4.08 3.86C4.22667 3.84667 4.36 3.84 4.48 3.84C4.61333 3.82667 4.74667 3.82 4.88 3.82C5.57333 3.82 6.14 3.94667 6.58 4.2C7.03333 4.45333 7.36667 4.88667 7.58 5.5C7.80667 6.11333 7.92 6.97333 7.92 8.08C7.92 9.65333 7.59333 10.8067 6.94 11.54C6.28667 12.26 5.4 12.6667 4.28 12.76L3.5 12.82V3.9ZM5.7 12.2C6.38 11.9067 6.88667 11.4333 7.22 10.78C7.55333 10.1133 7.72 9.21333 7.72 8.08C7.72 6.66667 7.52 5.65333 7.12 5.04C7.06667 5.02667 7.01333 5.02 6.96 5.02C6.90667 5.02 6.85333 5.02 6.8 5.02C6.68 5.02 6.56 5.02667 6.44 5.04C6.33333 5.04 6.22 5.04667 6.1 5.06L5.7 5.08V12.2Z"/>
          </svg>
        </span>
        <span class="ispan">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 6 17" height="18" width="6" class="letter i">
            <path fill="currentColor" d="M0.38 15.96V0.76L3.86 0.439999L5.86 1.44V16.64L2.38 16.94L0.38 15.96ZM0.58 0.94V15.74L3.66 15.46V0.66L0.58 0.94Z"/>
          </svg>
        </span>
        <span class="n">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 13 18" height="18" width="13" class="letter">
            <path fill="currentColor" d="M7.22 15.82L5.72 12.44V16.92L2.28 17.22L0.28 16.22V1.02L3.52 0.74L5.52 1.74L7 4.94V0.64L10.48 0.319999L12.48 1.32V16.54L9.22 16.82L7.22 15.82ZM7.2 0.819999V6.42C7.2 6.56667 7.20667 6.80667 7.22 7.14C7.23333 7.46 7.24667 7.8 7.26 8.16C7.28667 8.50667 7.30667 8.80667 7.32 9.06C7.33333 9.3 7.34 9.42 7.34 9.42L7.28 9.46C7.28 9.46 7.26 9.38667 7.22 9.24C7.19333 9.09333 7.14667 8.92 7.08 8.72C7.01333 8.50667 6.94 8.31333 6.86 8.14L3.4 0.959999L0.48 1.2V16L3.52 15.76V10.52C3.52 10.36 3.51333 10.0867 3.5 9.7C3.48667 9.31333 3.47333 8.90667 3.46 8.48C3.46 8.05333 3.45333 7.69333 3.44 7.4C3.42667 7.09333 3.42 6.94 3.42 6.94L3.48 6.92C3.48 6.92 3.51333 7.05333 3.58 7.32C3.66 7.57333 3.76667 7.84 3.9 8.12L7.4 15.62L10.28 15.36V0.539999L7.2 0.819999Z"/>
          </svg>
        </span>
        <span class="g">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 15 18" height="18" width="15" class="letter">
            <path fill="currentColor" d="M14.04 13.72C13.64 14.6533 12.9933 15.44 12.1 16.08C11.22 16.72 10.1333 17.0933 8.84 17.2C8.72 17.2133 8.6 17.22 8.48 17.22C8.36 17.22 8.24 17.22 8.12 17.22C7.12 17.22 6.16667 17.0467 5.26 16.7C4.36667 16.3533 3.57333 15.8333 2.88 15.14C2.18667 14.4333 1.64 13.54 1.24 12.46C0.84 11.38 0.64 10.1 0.64 8.62C0.64 7.48667 0.78 6.42667 1.06 5.44C1.34 4.44 1.74667 3.55333 2.28 2.78C2.82667 2.00667 3.48667 1.38667 4.26 0.92C5.03333 0.453333 5.90667 0.179999 6.88 0.0999997C6.96 0.0866657 7.04 0.0799987 7.12 0.0799987C7.2 0.0799987 7.28 0.0799987 7.36 0.0799987C8.33333 0.0799987 9.28 0.299999 10.2 0.74C11.1333 1.18 11.9467 1.78 12.64 2.54C13.3467 3.3 13.8467 4.16 14.14 5.12L11.76 6.46L12.04 6.44L14.04 7.44V13.72ZM5.9 7.16V10L8.98 9.74V11.46C8.80667 11.8067 8.52667 12.1067 8.14 12.36C7.76667 12.6 7.37333 12.7333 6.96 12.76C6.90667 12.7733 6.84667 12.78 6.78 12.78C6.72667 12.78 6.66667 12.78 6.6 12.78C5.73333 12.78 5.08 12.4333 4.64 11.74C4.2 11.0467 3.98 9.92 3.98 8.36C3.98 6.94667 4.20667 5.82 4.66 4.98C5.11333 4.14 5.84 3.68 6.84 3.6H7.06C7.60667 3.6 8.07333 3.76 8.46 4.08C8.86 4.4 9.14667 4.86667 9.32 5.48L11.9 4.02C11.6733 3.38 11.36 2.78 10.96 2.22C10.5733 1.64667 10.0867 1.18 9.5 0.819999C8.91333 0.459999 8.2 0.28 7.36 0.28C7.29333 0.28 7.22 0.28 7.14 0.28C7.06 0.28 6.98 0.286666 6.9 0.299999C5.63333 0.406666 4.54667 0.846666 3.64 1.62C2.73333 2.38 2.04 3.37333 1.56 4.6C1.08 5.81333 0.84 7.15333 0.84 8.62C0.84 10.14 1.06 11.4533 1.5 12.56C1.94 13.6667 2.56667 14.52 3.38 15.12C4.19333 15.72 5.16 16.02 6.28 16.02C6.37333 16.02 6.46 16.02 6.54 16.02C6.63333 16.02 6.72667 16.0133 6.82 16C8.07333 15.8933 9.12667 15.54 9.98 14.94C10.8467 14.3267 11.4733 13.5733 11.86 12.68V6.66L5.9 7.16ZM9.2 5.78C9.14667 5.59333 9.08667 5.42 9.02 5.26C8.95333 5.08667 8.88 4.93333 8.8 4.8C8.2 4.85333 7.70667 5.06667 7.32 5.44C6.94667 5.8 6.66667 6.29333 6.48 6.92L10.8 6.56L9.2 5.78ZM7.8 11.26L6.24 10.46C6.26667 10.9933 6.32 11.4133 6.4 11.72C6.49333 12.0133 6.62667 12.3 6.8 12.58C6.84 12.5667 6.88667 12.56 6.94 12.56C7.28667 12.5333 7.63333 12.4267 7.98 12.24C8.32667 12.04 8.59333 11.8067 8.78 11.54V11.14L7.8 11.26Z"/>
          </svg>
        </span>
      </div>
    </div>
    
    <div class="app-screen main-screen" id="mainScreen">
        <div class="balance" id="shibBalance">0 SHIB</div>
        
        <div class="progress-group-container">
            <div class="daily-progress-container">
                <div class="daily-progress-text">Ads today: <span id="adsCount">0</span> / 200</div>
                <div class="daily-progress-bar">
                    <div class="daily-progress-fill" id="dailyProgressFill"></div>
                </div>
            </div>
            <div class="spin-progress-container">
                <div class="spin-progress-text">Spins today: <span id="spinsCount">0</span> / 25</div>
                <div class="spin-progress-bar">
                    <div class="spin-progress-fill" id="spinProgressFill"></div>
                </div>
            </div>
        </div>
        
        <div class="user-circle" onclick="circleClick()">
            <img id="userImage" src="" alt="User">
            <div class="placeholder">+</div>
        </div>
        <div class="user-username" id="userName"></div>
        <div class="user-id" id="userId"></div>
        
        <div class="main-content"></div>
        
        <div class="button-container">
            <button class="nav-button" onclick="watchAds()"><span>Ads</span></button>
            <button class="nav-button task-btn" onclick="showTask()"><span>Task</span></button>
            <button class="nav-button" onclick="showSpin()"><span>Spin</span></button>
            <button class="nav-button withdraw-btn-nav" onclick="showWithdraw()"><span>Withdraw</span></button>
            <button class="nav-button" onclick="inviteFriends()"><span>Invite</span></button>
        </div>
        </div>

    <div class="app-screen task-screen" id="taskScreen">
        <div class="task-header">
            <h2 class="task-title">Daily Tasks</h2>
        </div>
        
        <div class="task-content-container" id="taskContentContainer">
            <div id="taskLinkArea" class="task-link-container" style="display:none;">
                <div class="task-link-title">
                    <span>Open and get 5 SHIB</span>
                    <span id="taskLinkCountDisplay">0 / 200</span>
                </div>
                <div class="task-link-progress-bar">
                    <div class="task-link-progress-fill" id="taskLinkProgressFill" style="width:0%"></div>
                </div>
                <button class="task-link-button" id="taskLinkBtn" onclick="handleTaskLinkClick()">Open and get 5 SHIB</button>
            </div>

            <div id="taskListContainer">
                </div>

            <div id="noChannelTasksNotice" class="no-channel-tasks" style="display:none;">No channel tasks now.</div>
        </div>

        <button class="task-back-btn" onclick="hideTask()">Back to Main</button>
    </div>

    <div class="app-screen spin-screen" id="spinScreen">
        <div id="wheelBox">
            <div class="arrow"></div>
            <canvas id="wheelCanvas" width="280" height="280"></canvas>
        </div>
        <button class="spin-btn" id="spinBtn" onclick="startSpin()">SPIN</button>
        <div class="spin-result" id="spinResult"></div>
        <button class="spin-back" onclick="hideSpin()">Back</button>
    </div>

    <div class="app-screen withdraw-screen" id="withdrawScreen">
        <div class="withdraw-header">
            <h2 class="withdraw-title">üí∞ Request SHIB Withdrawal</h2>
            <div class="current-balance-info">Your Balance: <span id="withdrawBalanceDisplay">0 SHIB</span></div>
        </div>
        
        <div class="input-form-container">
            <div class="input-group">
                <label>Binance User ID</label>
                <input type="text" id="binanceId" placeholder="FaucetPay or Binance ID">
            </div>
            <div class="input-group">
                <label>Amount in SHIB (Min 2000)</label>
                <input type="number" id="withdrawAmount" min="2000" value="" placeholder="">
            </div>
            <div class="withdraw-buttons">
                <button class="withdraw-btn" onclick="confirmWithdraw()">Send Request</button>
            </div>
        </div>
        
        <div class="note">
            ‚ö†Ô∏è **Important:** The withdrawal will be processed manually within **24 hours**. Ensure your Binance ID is correct.
        </div>
        
        <div class="history-section">
            <h3 class="history-title">Withdrawal History</h3>
            <div id="withdrawalHistoryContainer">
                </div>
        </div>

        <button class="back-btn" onclick="hideWithdraw()">Back to Main</button>
    </div>

    <div class="app-screen invite-screen" id="inviteScreen">
        <div class="invite-header">
            <h2 class="invite-title">ü§ù Invite Friends & Earn SHIB</h2>
            <div class="referrals-count-info">
                Your Referrals: <span id="referralsCountDisplay">0</span>
            </div>
        </div>
        
        <div class="input-form-container">
            <div class="input-group">
                <label>Your Referral Link</label>
                <input type="text" id="referralLinkInput" readonly value="Generating Link...">
            </div>
            <div class="invite-buttons">
                <button class="copy-link-btn" onclick="copyReferralLink()">Copy Link</button>
            </div>
        </div>
        
        <div class="note">
       
üöÄ Share this link to invite new users.
You will earn 40% of the revenue from every referral you bring through ads!
        </div>

        <button class="back-btn" onclick="hideInvite()">Back to Main</button>
    </div>
    
    <div id="customAlert" class="custom-alert-overlay">
        <div class="custom-alert-box">
            <div class="alert-icon" id="alertIcon"></div>
            <div class="alert-title" id="alertTitle"></div>
            <div class="alert-message" id="alertMessage"></div>
            <button class="alert-close-btn" onclick="document.getElementById('customAlert').classList.remove('visible')">OK</button>
        </div>
    </div>

    <!-- Background audio player (playlist managed in JS): audio.mp3, audio2.mp3, audio3.mp3, audio4.mp3 -->
    <audio id="bgPlayer">
        <source id="bgSource" src="audio.mp3" type="audio/mp3">
        Your browser does not support the audio element.
    </audio>

    <audio id="successSFX">
        <source src="success.mp3" type="audio/mp3"> 
    </audio>
    <audio id="errorSFX">
        <source src="error.mp3" type="audio/mp3"> 
    </audio>

    <script src='//libtl.com/sdk.js' data-zone='10245709' data-sdk='show_10245709'></script>
    <script>
        /* ===== Loading ===== */
        const loadingScreen = document.getElementById('loadingScreen');
        const mainScreen = document.getElementById('mainScreen');

        // Removed the old loading bar logic

        document.addEventListener('DOMContentLoaded',()=>{
            // Simulating a brief loading time for the spinner to be visible
            setTimeout(async ()=>{ 
                // Wait for init (register + loadUserData) to complete before hiding loading screen
                // This prevents abrupt immediate transition when loading finishes and ensures UI is ready
                await initDailyProgress(); 
                // hide with existing CSS fade
                loadingScreen.classList.add('hidden');
                playBGAudio(); 
            }, 7000); 
        });
        
        /* ===== Custom Alert & Audio Functions ===== */
        
        const bgPlayer = document.getElementById('bgPlayer');
        const successSFX = document.getElementById('successSFX');
        const errorSFX = document.getElementById('errorSFX');
        const customAlert = document.getElementById('customAlert');
        const alertBox = customAlert.querySelector('.custom-alert-box');
        const alertTitleEl = document.getElementById('alertTitle');
        const alertMessageEl = document.getElementById('alertMessage');
        const alertIconEl = document.getElementById('alertIcon');

        // Playlist for background: per request use these files
        const bgPlaylist = ['audio.mp3', 'audio2.mp3', 'audio3.mp3', 'audio4.mp3'];
        let currentBgIndex = -1;

        function getRandomBgIndex(excludeIndex = -1) {
            if (!Array.isArray(bgPlaylist) || bgPlaylist.length === 0) return -1;
            if (bgPlaylist.length === 1) return 0;
            let idx;
            // Avoid immediate repeat when possible
            do {
                idx = Math.floor(Math.random() * bgPlaylist.length);
            } while (idx === excludeIndex && bgPlaylist.length > 1);
            return idx;
        }

        function playNextBg() {
            const next = getRandomBgIndex(currentBgIndex);
            if (next === -1) return;
            currentBgIndex = next;
            // set src and play
            try {
                // Some browsers require setting src on the audio element
                bgPlayer.src = bgPlaylist[next];
                bgPlayer.load();
                bgPlayer.volume = 0.4;
                bgPlayer.play().catch(e => {
                    // Will often fail until user interacts; log and continue
                    console.log("bgPlayer play failed (will wait for user interaction):", e);
                });
            } catch (e) {
                console.warn("Failed to set bgPlayer source:", e);
            }
        }

        // When a track ends, play another randomly as requested
        bgPlayer.addEventListener('ended', () => {
            // Play next random track
            playNextBg();
        });

        /**
         * Plays background music. Must be called after user interaction.
         */
        function playBGAudio() {
            // Attempt to play only if it's paused or not playing
            try {
                if (bgPlayer.paused || !bgPlayer.currentSrc) {
                    playNextBg();
                }
            } catch (e) {
                console.log("Background audio play failed, waiting for user click:", e);
            }
        }
        
        /**
         * Plays a sound effect (Success or Error).
         */
        function playSFX(type) {
            let sfx;
            if (type === 'success') {
                sfx = successSFX;
            } else if (type === 'error') {
                sfx = errorSFX;
            } else {
                return;
            }
            sfx.currentTime = 0; // Rewind to start
            sfx.volume = 0.8;
            sfx.play().catch(e => console.log("SFX play failed:", e));
        }

        /**
         * Shows a custom, styled alert modal.
         * @param {string} title - The title of the alert.
         * @param {string} message - The message content.
         * @param {'success'|'error'|'warning'} type - The type of alert.
         */
        function showCustomAlert(title, message, type = 'warning') {
            const finalTitle = title;
            const finalMessage = message.replace(/(\r\n|\n|\r)/gm, "\n"); 

            alertTitleEl.textContent = finalTitle;
            alertMessageEl.textContent = finalMessage;

            alertBox.classList.remove('success', 'error', 'warning');
            alertBox.classList.add(type);

            customAlert.classList.add('visible');
            
            playSFX(type === 'error' ? 'error' : 'success'); 
        }


        /* ===== Telegram User & Referral Setup (Modified to include audio) ===== */
        Telegram.WebApp.ready();
        
        let tgUser = null;
        if(Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user){
            tgUser = Telegram.WebApp.initDataUnsafe.user;
            const photoUrl = tgUser.photo_url;
            const userName = tgUser.first_name + (tgUser.last_name? ' '+tgUser.last_name:'');
            const userId = tgUser.id;
            const imgEl  = document.getElementById('userImage');
            const nameEl = document.getElementById('userName');
            const idEl   = document.getElementById('userId');
            const placeHolder = document.querySelector('.placeholder');
            if(photoUrl){
                imgEl.src = photoUrl;
                imgEl.style.display = 'block';
                placeHolder.style.display = 'none';
            }
            nameEl.textContent = userName;
            idEl.textContent   = 'ID: ' + userId;
        }

        function getRefParam() {
            let referrerId = null;
            const REF_PREFIX = 'ref_';

            if (Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.start_param) {
                const startParam = Telegram.WebApp.initDataUnsafe.start_param;
                if (startParam.startsWith(REF_PREFIX)) {
                    referrerId = startParam.substring(REF_PREFIX.length);
                    console.log('Referrer ID from start_param:', referrerId);
                }
            } 
            return referrerId; 
        }

        let referrerId = getRefParam();
        const API_URL = '/api'; 
        
        // ------------------------------------------------------------------
        // **fetchApi Function** // ------------------------------------------------------------------
        async function fetchApi(payload) {
            if (!tgUser) {
                // English translation of the Arabic alert message
                showCustomAlert('Critical Error!', 'User data not initialized. Please restart the app. [CODE: U_NIL]', 'error');
                return { ok: false, error: 'User not initialized' };
            }

            const initData = Telegram.WebApp.initData;
            if (!initData) {
                // English translation of the Arabic alert message
                showCustomAlert('Critical Error!', 'Initialization data is missing. Please restart the app. [CODE: ID_MS]', 'error');
                return { ok: false, error: 'InitData missing' };
            }

            if (typeof Telegram.WebApp.showProgress === 'function') {
                Telegram.WebApp.showProgress();
            }
            
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        ...payload,
                        user_id: tgUser.id,
                        initData: initData 
                    }),
                });

                if (typeof Telegram.WebApp.hideProgress === 'function') {
                    Telegram.WebApp.hideProgress();
                }

                const data = await response.json();

                if (!response.ok || !data.ok) {
                    const errorMessage = data.error || `Server Error: ${response.status} ${response.statusText}`;
                    console.error(`API Call failed for type ${payload.type}:`, errorMessage);
                    let alertTitle = 'Operation Failed!';
                    let alertType = 'error';
                    let cleanMessage = errorMessage;

                    if (response.status === 429) {
                        alertTitle = 'Rate Limit Exceeded!';
                        alertType = 'warning';
                        cleanMessage = 'You have exceeded the allowed request limit. Please try again after 5 second.';
                    } else if (errorMessage.includes('banned')) {
                        alertTitle = 'Access Denied!';
                        alertType = 'error';
                        cleanMessage = 'This account has been banned.';
                    } else if (errorMessage.includes('limit reached')) {
                        alertTitle = 'Daily Limit Reached!';
                        alertType = 'warning';
                        cleanMessage = 'You have reached the maximum number of allowed actions for today.';
                    } else if (errorMessage.includes('Server Token') || response.status === 409 || response.status === 408) {
                        alertTitle = 'Security Error!';
                        alertType = 'error';
                        cleanMessage = 'A security-related error occurred. Please try again.';
                    } else if (payload.type === 'completeTask' && errorMessage.includes('already completed')) {
                        alertTitle = 'Task Completed!';
                        alertType = 'warning';
                        cleanMessage = 'Reward already claimed. Task is complete.';
                    } else if (payload.type === 'completeTask' && errorMessage.includes('not joined')) {
                        alertTitle = 'Task Failed!';
                        alertType = 'error';
                        cleanMessage = 'Membership not verified. Please ensure you joined the channel and try again.';
                    } else {
                        // General error handling (English)
                        alertTitle = 'Operation Failed!';
                        alertType = 'error';
                        cleanMessage = errorMessage;
                    }
                    
                    showCustomAlert(alertTitle, cleanMessage, alertType);
                    return { ok: false, error: errorMessage };
                }

                return data;
            } catch (error) {
                if (typeof Telegram.WebApp.hideProgress === 'function') {
                    Telegram.WebApp.hideProgress();
                }
                console.error(`General Fetch Error for type ${payload.type}:`, error.message);
                // English translation of the Arabic alert message
                showCustomAlert('Connection Error!', 'Could not connect to the server. Please check your internet connection.', 'error');
                return { ok: false, error: error.message };
            }
        }

        // ------------------------------------------------------------------
        // NEW: Function to request Action ID from the Server
        // ------------------------------------------------------------------
        async function requestActionId(actionType) {
            const result = await fetchApi({ 
                type: 'generateActionId', 
                action_type: actionType 
            });
            
            if (result.ok) {
                return result.data.action_id;
            }
            return null;
        }


        /* ===== Rewards, Limits, and Anti-Cheat (Limits here are for display only) ===== */
        const DAILY_MAX = 200;
        const DAILY_MAX_SPINS = 25;
        
        let shibBalance = 0; 
        let adsWatchedToday = 0;
        let spinsToday = 0; 
        let taskCompleted = false; 
        let taskActionState = 'JOIN_OR_CLAIM'; // NEW: State variable for the button's action
        let withdrawalHistory = [];
        let referralsCount = 0; 
        let isBanned = false; 
        let isProcessingTask = false; 
        let countdownInterval = null; // New variable for the countdown interval
        
        const sectors = [5, 10, 15, 20, 5]; 

        // New: currentTask holds the selected task's data (id, link, reward, is_completed)
        let currentTask = null;

        // ===== Task Link Constants and state (local-storage based) =====
        const TASK_LINK_KEY = 'taskLinkProgress_v1';
        const TASK_LINK_DAILY_MAX = 200; // daily limit (count)
        const TASK_LINK_REWARD = 5; // 5 SHIB per click
        const TASK_LINK_URL = 'https://otieu.com/4/10259911';

        let taskLinkState = { date: null, count: 0 }; // {date:'YYYY-MM-DD', count: number}

        function todayDateString() {
            const d = new Date();
            return d.toISOString().slice(0,10);
        }

        function loadTaskLinkProgressFromStorage() {
            try {
                const raw = localStorage.getItem(TASK_LINK_KEY);
                if (!raw) {
                    taskLinkState = { date: todayDateString(), count: 0 };
                    localStorage.setItem(TASK_LINK_KEY, JSON.stringify(taskLinkState));
                    return;
                }
                const parsed = JSON.parse(raw);
                if (!parsed || parsed.date !== todayDateString()) {
                    // reset for new day
                    taskLinkState = { date: todayDateString(), count: 0 };
                    localStorage.setItem(TASK_LINK_KEY, JSON.stringify(taskLinkState));
                    return;
                }
                taskLinkState = parsed;
            } catch (e) {
                console.warn('Failed to load task link progress from localStorage:', e);
                taskLinkState = { date: todayDateString(), count: 0 };
            }
        }

        function saveTaskLinkProgressToStorage() {
            try {
                taskLinkState.date = todayDateString();
                localStorage.setItem(TASK_LINK_KEY, JSON.stringify(taskLinkState));
            } catch (e) {
                console.warn('Failed to save task link progress to localStorage:', e);
            }
        }

        function updateTaskLinkUI() {
            const area = document.getElementById('taskLinkArea');
            const fill = document.getElementById('taskLinkProgressFill');
            const countDisplay = document.getElementById('taskLinkCountDisplay');
            const btn = document.getElementById('taskLinkBtn');

            if (!area || !fill || !countDisplay || !btn) return;

            // show area always (we can hide in future if not needed)
            area.style.display = 'block';

            const count = taskLinkState.count || 0;
            const percent = Math.min((count / TASK_LINK_DAILY_MAX) * 100, 100);
            fill.style.width = percent + '%';
            countDisplay.textContent = `${count} / ${TASK_LINK_DAILY_MAX}`;

            if (count >= TASK_LINK_DAILY_MAX) {
                btn.disabled = true;
                btn.textContent = 'Daily Limit Reached';
            } else {
                btn.disabled = false;
                btn.textContent = 'Open and get 5 SHIB';
            }
        }

        /**
         * Handle task link click:
         * - Request server action id
         * - Open external link
         * - Send server notification (taskLinkClick) with action_id & url
         * - If server returns ok, use server's balance; otherwise fallback to local award
         * - Show a minimal success alert: title "Reward", message "5 SHIB"
         */
        async function handleTaskLinkClick() {
            if (isBanned) {
                showCustomAlert('Access Denied!', 'This account has been banned.', 'error');
                return;
            }

            // If reached daily max
            if (taskLinkState.count >= TASK_LINK_DAILY_MAX) {
                showCustomAlert('Daily Limit Reached!', `You have reached the daily limit for these instant links (${TASK_LINK_DAILY_MAX}).`, 'warning');
                updateTaskLinkUI();
                return;
            }

            // 1. Request Action ID from server (best-effort)
            let actionId = null;
            try {
                actionId = await requestActionId('taskLink');
            } catch (e) {
                console.warn('Failed to get action id for task link:', e);
                actionId = null;
            }

            // 2. Open link (user experience)
            const opened = openExternalLink(TASK_LINK_URL);

            // 3. Try to notify server about the click (if we have an action id)
            let serverResult = { ok: false };
            if (actionId) {
                try {
                    serverResult = await fetchApi({
                        type: 'taskLinkClick',
                        action_id: actionId,
                        url: TASK_LINK_URL
                    });
                } catch (e) {
                    serverResult = { ok: false };
                }
            }

            // 4. If server returned success and provided new_balance, use it and update local progress
            if (serverResult && serverResult.ok) {
                if (serverResult.data && serverResult.data.new_balance !== undefined) {
                    shibBalance = serverResult.data.new_balance;
                    
                    // The server confirmed the award and incremented its counter (new_count)
                    // We sync our local counter with the server's response to prevent local-storage abuse
                    taskLinkState.count = serverResult.data.new_count;
                    saveTaskLinkProgressToStorage();
                    
                    updateState({ balance: shibBalance });
                    updateTaskLinkUI();

                    // Minimal success alert as requested: only "Reward" and "5 SHIB"
                    showCustomAlert('Reward', '5 SHIB', 'success');
                } else {
                    // Server returned OK but no data: Should not happen, but treat as an error/warning
                    showCustomAlert('Server Sync Warning', 'The server accepted the click but did not return updated data. Please reload the app.', 'warning');
                }
                return;
            }
            
            // 5. If server failed, we should NOT award locally (removed local fallback reward logic)
            
            // If the server call failed (and fetchApi showed an error) or if we couldn't get an action ID, 
            // the user must try again to get the server-side reward. 
            // We just ensure the UI is updated from the server's side after failure.
            loadUserData();
        }

        // ------------------------------------------------------------------

        function updateState(data) {
            shibBalance = data.balance !== undefined ? data.balance : shibBalance;
            adsWatchedToday = data.ads_watched_today !== undefined ? data.ads_watched_today : adsWatchedToday;
            spinsToday = data.spins_today !== undefined ? data.spins_today : spinsToday;
            referralsCount = data.referrals_count !== undefined ? data.referrals_count : referralsCount;
            withdrawalHistory = data.withdrawal_history !== undefined ? data.withdrawal_history : withdrawalHistory;
            isBanned = data.is_banned !== undefined ? data.is_banned : isBanned;
            // Handle taskCompleted update and state reset if successful (legacy)
            if (data.task_completed === true) {
                taskCompleted = true;
                taskActionState = 'COMPLETED';
            } else if (data.task_completed === false) {
                 taskCompleted = false;
            }

            updateUI();
        }
        
        async function loadUserData() {
            if (!tgUser) return;
            
            const result = await fetchApi({ type: 'getUserData' }); 

            if (result.ok) {
                if (result.data.is_banned) {
                    isBanned = true;
                    mainScreen.classList.remove('visible');
                    // English translation of the Arabic alert message
                    showCustomAlert('Account Banned!', 'This account has been permanently restricted for violating policies. Access to the Mini App is denied.', 'error');
                    return;
                }
                
                updateState({
                    balance: result.data.balance,
                    ads_watched_today: result.data.ads_watched_today,
                    spins_today: result.data.spins_today,
                    referrals_count: result.data.referrals_count,
                    is_banned: false, 
                    task_completed: result.data.task_completed || false, // Default to false
                    withdrawal_history: (result.data.withdrawal_history || []).map(item => ({
                        amount: item.amount,
                        status: item.status,
                        date: new Date(item.created_at).toLocaleDateString('en-GB') 
                    }))
                });

                // Sync local taskLinkState.count with server data if available
                if (result.data.task_link_clicks_today !== undefined) {
                    taskLinkState.count = result.data.task_link_clicks_today;
                    saveTaskLinkProgressToStorage(); // Save the synchronized value
                }

                // Set taskActionState based on loaded data
                if (taskCompleted) {
                    taskActionState = 'COMPLETED';
                } else if (taskActionState === 'COMPLETED') { 
                    // Prevents resetting to COMPLETED if an error occurred during claim
                    taskActionState = 'JOIN_OR_CLAIM';
                }
                
                mainScreen.classList.add('visible'); 

            }
        }
        
        async function initDailyProgress(){
            if (!tgUser) return;

            const registerResult = await fetchApi({ 
                type: 'register',
                ref_by: referrerId ? referrerId : null 
            });

            if (registerResult.ok) {
                await loadUserData(); 
            }
        }
        
        function updateUI(){
            document.getElementById('shibBalance').textContent = shibBalance.toLocaleString() + ' SHIB';
            document.getElementById('withdrawBalanceDisplay').textContent = shibBalance.toLocaleString() + ' SHIB';

            document.getElementById('adsCount').textContent = adsWatchedToday;
            const adsPercent = Math.min((adsWatchedToday / DAILY_MAX) * 100, 100);
            document.getElementById('dailyProgressFill').style.width = adsPercent + '%';

            document.getElementById('spinsCount').textContent = spinsToday; 
            const spinsPercent = Math.min((spinsToday / DAILY_MAX_SPINS) * 100, 100);
            document.getElementById('spinProgressFill').style.width = spinsPercent + '%';

            document.getElementById('referralsCountDisplay').textContent = referralsCount.toLocaleString();
            
            // Attempt to find per-task button for the selected task if exists
            const perTaskBtn = currentTask ? document.querySelector(`button[data-task-id="${currentTask.id}"]`) : null;

            if (perTaskBtn) {
                if (!isProcessingTask && countdownInterval) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                }

                if (currentTask && currentTask.is_completed) {
                    perTaskBtn.disabled = true;
                    perTaskBtn.textContent = 'Claimed';
                    perTaskBtn.classList.add('completed');
                } else {
                    perTaskBtn.disabled = isProcessingTask || perTaskBtn.dataset.locked === '1';
                    perTaskBtn.classList.remove('completed');

                    if (isProcessingTask) {
                        // text managed by claimTaskReward countdown
                    } else if (taskActionState === 'CLAIM') {
                        perTaskBtn.textContent = 'Claim';
                    } else {
                        perTaskBtn.textContent = 'Open';
                    }
                }
            }

            const adButton = document.querySelector('button[onclick="watchAds()"]');
            if (adButton) {
                if (isBanned || adsWatchedToday >= DAILY_MAX) {
                    adButton.disabled = true;
                    adButton.querySelector('span').textContent = 'LIMIT REACHED';
                } else {
                    adButton.disabled = false;
                    adButton.querySelector('span').textContent = 'Ads';
                }
            }

            const spinBtn = document.getElementById('spinBtn');
            if (spinBtn) {
                if (spinBtn) {
                    if (isBanned || spinsToday >= DAILY_MAX_SPINS) {
                        spinBtn.disabled = true;
                        spinBtn.textContent = `LIMIT REACHED (${spinsToday}/${DAILY_MAX_SPINS})`;
                    } else if (!spinning) {
                        spinBtn.disabled = false;
                        spinBtn.textContent = 'SPIN';
                    }
                }
            }

            // update task link UI as well
            updateTaskLinkUI();
        }
        
        // ***************************************************************
        // UPDATED watchAds FUNCTION FOR TWO SEQUENTIAL ADS (NO INTERMEDIATE ALERTS)
        // ***************************************************************
        async function watchAds(){
            if (isBanned) {
                 // English translation of the Arabic alert message
                 showCustomAlert('Access Denied!', 'This account has been banned.', 'error');
                 return;
            }
            
            if (adsWatchedToday >= DAILY_MAX) {
                showCustomAlert('Daily Limit Reached!', `Ôº°Ôº¨Ôº¨ ÔΩÅÔΩÑÔΩì Ôº§ÔΩèÔΩéÔΩÖ (${DAILY_MAX}). Ôº£ÔΩèÔΩçÔΩÖ ÔΩÇÔΩÅÔΩÉÔΩã Ôº°ÔΩÜÔΩîÔΩÖÔΩí 6 Ôº®ÔΩèÔΩïÔΩíÔΩìü•©!`, 'warning');
                return;
            }

            // 1. Request Action ID from the Server
            const actionId = await requestActionId('watchAd');
            if (!actionId) return; // Error message already shown by fetchApi

            // 2. Show First Ad - NO ALERT HERE
            show_10245709()
                .then(() => {
                    // Success for Ad 1 - Immediately start the second ad - NO ALERT HERE
                    return show_10245709();
                })
                .then(async () => {
                    // Success for Ad 2 -> Proceed to reward logic
                    
                    // 3. Request ad reward from the server (Server determines reward, checks limits, and validates Action ID)
                    const adResult = await fetchApi({
                        type: 'watchAd',
                        action_id: actionId // ‚¨ÖÔ∏è Send Server-Issued ID
                    });

                    if (adResult.ok) {
                        const actualReward = adResult.data.actual_reward; 
                        
                        // 4. Update UI with trusted server values
                        updateState({
                            balance: adResult.data.new_balance,
                            ads_watched_today: adResult.data.new_ads_count
                        });
                        
                        // 5. Referral commission logic
                        if (referrerId) {
                            fetchApi({
                                type: 'commission',
                                referrer_id: referrerId,
                                referee_id: tgUser.id
                            }).then(r => {
                                if (r.ok) { console.log('Commission sent successfully.'); }
                                else { console.warn('Commission failed to send:', r.error); }
                            });
                        }
                        
                        // 6. Custom Alert for Success (in English)
                        let alertTitle = 'Reward Granted!';
                        let alertType = 'success';
                        let alertMessage = ` ÔºπÔºØÔºµ Ôº∑Ôº©ÔºÆ ${actualReward} SHIB.`;
                        
                        if(adResult.data.new_ads_count >= DAILY_MAX){
                            alertTitle = 'Daily Task Completed!';
                            // **UPDATED MESSAGE HERE** to 'Come back in 6 hours.'
                            alertMessage = `Congratulations! You have completed all today's ads (${DAILY_MAX}). Ôº£ÔºØÔº≠Ôº• ÔΩÇÔΩÅÔΩÉÔΩã ÔΩÅÔΩÜÔΩîÔΩÖÔΩí 6 Ôº®ÔΩèÔΩïÔΩíÔΩì!`;
                        }
                        showCustomAlert(alertTitle, alertMessage, alertType);

                    }
                })
                .catch(e => {
                    // Catch block handles failure for either Ad 1 or Ad 2
                    console.error("libtl.com Ad sequence failed:", e);
                    if (typeof e === 'string' && e.includes('canceled')) {
                        // English translation of the Arabic alert message
                        showCustomAlert('Ad Cancelled/Failed!', 'The ad sequence was interrupted. Please watch both ads completely to receive the reward.', 'warning');
                    } else {
                        // English translation of the Arabic alert message
                        showCustomAlert('Ad Load Failed!', 'One of the ads failed to load. Please try again.', 'error');
                    }
                });
        }
        // ***************************************************************
        // END OF UPDATED watchAds FUNCTION
        // ***************************************************************
        
        function circleClick(){ console.log('Circle clicked'); }

        /* ===== Task Screen Functions (UPDATED LOGIC with dynamic tasks) ===== */

        /**
         * fetchTasks - requests tasks list from server (type: 'getTasks')
         * returns array of tasks or empty array
         */
        async function fetchTasks() {
            const res = await fetchApi({ type: 'getTasks' });
            if (res.ok && Array.isArray(res.data.tasks)) {
                return res.data.tasks;
            }
            return [];
        }

        /**
         * fetchTask - helper to fetch a single task by id.
         * Uses fetchTasks internally (server does not provide single-task endpoint currently).
         */
        async function fetchTask(taskId) {
            const tasks = await fetchTasks();
            return tasks.find(t => parseInt(t.task_id) === parseInt(taskId)) || null;
        }

        /**
         * Normalize a task link (ensure full https://t.me/... if it is t.me/...)
         */
        function normalizeTaskLink(link) {
            if (!link) return '';
            link = link.trim();
            // If link starts with t.me/... but without protocol
            if (/^t\.me\//i.test(link)) {
                return 'https://' + link;
            }
            // If link starts with @username (unlikely) convert to t.me
            if (/^@/.test(link)) {
                return 'https://t.me/' + link.substring(1);
            }
            // If link missing protocol but starts with www or contains t.me anywhere, ensure protocol
            if (!/^https?:\/\//i.test(link)) {
                return 'https://' + link;
            }
            return link;
        }

        /**
         * Open a link using Telegram WebApp method when possible, otherwise fallback to window.open
         */
        function openExternalLink(link) {
            if (!link) return false;
            const normalized = normalizeTaskLink(link);
            try {
                if (typeof Telegram !== 'undefined' && Telegram.WebApp && typeof Telegram.WebApp.openTelegramLink === 'function') {
                    // openTelegramLink expects a t.me link or tg:// link
                    Telegram.WebApp.openTelegramLink(normalized);
                    return true;
                } else {
                    window.open(normalized, '_blank');
                    return true;
                }
            } catch (e) {
                console.warn('Failed to open link via WebApp, fallback to window.open:', e);
                try { window.open(normalized, '_blank'); return true; } catch (err) { return false; }
            }
        }

        /**
         * Renders tasks list into the task screen, keeping the original card appearance.
         * Each task button now both selects the task and immediately opens the link.
         *
         * NOTE: Tasks that are already completed are not shown (they disappear).
         *
         * When there are no available tasks, show a minimal English notice ""
         */
        function renderTasksList(tasks) {
            const container = document.getElementById('taskListContainer');
            const noChannelNotice = document.getElementById('noChannelTasksNotice');
            if (!container) return;

            // Filter out completed tasks so they do not appear to the user
            const availableTasks = Array.isArray(tasks) ? tasks.filter(t => !t.is_completed) : [];

            if (!Array.isArray(availableTasks) || availableTasks.length === 0) {
                // Only show a simple "No tasks now." message as requested (remove Unavailable button)
                container.innerHTML = `
                    <div class="task-item-card">
                        <span class="task-text-info">No tasks now.</span>
                    </div>
                `;
                if (noChannelNotice) noChannelNotice.style.display = 'none';
                return;
            }

            if (noChannelNotice) noChannelNotice.style.display = 'none';

            const html = availableTasks.map(t => {
                const rewardText = `Reward: ${t.reward} SHIB`;
                const safeLink = (t.link || '').replace(/"/g, '&quot;');
                return `
                    <div class="task-item-card" data-task-id="${t.task_id}">
                        <span class="task-text-info">${t.name} ‚Äî ${rewardText}</span>
                        <button class="task-action-btn-new" data-task-link="${safeLink}" data-task-id="${t.task_id}" onclick="onTaskButtonClick(event)">
                            Open
                        </button>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        /**
         * onTaskButtonClick - handles clicks on the per-task button.
         * Dual behaviour on the same button:
         * - First click: open the external link (if present) and switch the button to "Claim".
         * - Second click (when button shows "Claim"): start the verification & claim flow for that task.
         *
         * Added: per-button lock to prevent rapid multiple claim requests.
         */
        async function onTaskButtonClick(event) {
            event = event || window.event;
            const btn = event.currentTarget || event.target;
            const taskId = btn.getAttribute('data-task-id');
            const taskLink = btn.getAttribute('data-task-link') || '';

            if (!taskId) {
                showCustomAlert('Task Error', 'Task id not found on this button.', 'error');
                return;
            }

            // Prevent multiple rapid clicks using dataset lock
            if (btn.dataset.locked === '1') {
                // Already processing or locked
                return;
            }

            // If user clicked a button already switched to "Claim", start claim flow
            const btnText = (btn.textContent || '').trim().toLowerCase();
            if (btnText === 'claim') {
                // Lock the button immediately to prevent multiple claim requests
                btn.dataset.locked = '1';
                btn.disabled = true;

                // If already processing globally, release and ignore
                if (isProcessingTask) {
                    btn.dataset.locked = '0';
                    btn.disabled = false;
                    return;
                }

                // Set currentTask and trigger claim flow
                const task = await fetchTask(taskId);
                if (!task) {
                    btn.dataset.locked = '0';
                    btn.disabled = false;
                    showCustomAlert('Task Error', 'Selected task not found. Please refresh the tasks list.', 'error');
                    return;
                }
                currentTask = {
                    id: parseInt(task.task_id),
                    name: task.name,
                    link: task.link,
                    reward: task.reward,
                    is_completed: !!task.is_completed
                };

                if (currentTask.is_completed) {
                    // If already completed server-side, remove element and notify
                    const el = document.querySelector(`div[data-task-id="${taskId}"]`);
                    if (el) el.remove();
                    btn.dataset.locked = '0';
                    btn.disabled = false;
                    showCustomAlert('Task Completed!', 'Reward already claimed for this task.', 'warning');
                    return;
                }

                // Begin the claim flow using the normal function (which uses currentTask)
                claimTaskReward();
                return;
            }

            // Otherwise treat as first click: select task and open link
            const task = await fetchTask(taskId);
            if (!task) {
                showCustomAlert('Task Error', 'Selected task not found. Please refresh the tasks list.', 'error');
                return;
            }

            currentTask = {
                id: parseInt(task.task_id),
                name: task.name,
                link: task.link,
                reward: task.reward,
                is_completed: !!task.is_completed
            };

            if (currentTask.is_completed) {
                // If already completed server-side, remove the task card from UI
                const el = document.querySelector(`div[data-task-id="${taskId}"]`);
                if (el) el.remove();
                showCustomAlert('Task Completed!', 'Reward already claimed for this task.', 'warning');
                return;
            }

            // Try to open link immediately
            if (taskLink && taskLink.trim() !== '') {
                const opened = openExternalLink(taskLink);
                if (opened) {
                    // Switch this button to "Claim" (second click will start verification)
                    btn.textContent = 'Claim';
                    // Provide guidance
                    showCustomAlert('Opened Task', 'The task has been opened. After joining press "Claim" to receive the reward.', 'warning');
                    // ensure button is enabled for next click (unlock)
                    btn.dataset.locked = '0';
                    btn.disabled = false;
                } else {
                    showCustomAlert('Open Link Failed', 'Unable to open the link. Please try manually.', 'error');
                }
            } else {
                // No link: allow user to attempt direct verification by changing to Claim
                btn.textContent = 'Claim';
                showCustomAlert('No Link', 'This task has no join link. Press Claim to attempt verification.', 'warning');
                btn.dataset.locked = '0';
                btn.disabled = false;
            }
        }

        /**
         * selectTask kept for backward compatibility if you want to call directly.
         * It will now click the matching per-task button if present.
         */
        async function selectTask(taskId) {
            const btn = document.querySelector(`#taskListContainer button[data-task-id="${taskId}"]`);
            if (btn) {
                btn.click();
                return;
            }
            const task = await fetchTask(taskId);
            if (!task) {
                showCustomAlert('Task Error', 'Selected task not found. Please refresh the tasks list.', 'error');
                return;
            }
            currentTask = {
                id: parseInt(task.task_id),
                name: task.name,
                link: task.link,
                reward: task.reward,
                is_completed: !!task.is_completed
            };
            showCustomAlert('Task Selected', `Selected: ${currentTask.name}\nReward: ${currentTask.reward} SHIB`, 'warning');
        }

        // ** MODIFIED: Now displays the actual task screen and loads tasks **
        async function showTask(){
            if (isBanned) {
                 showCustomAlert('Access Denied!', 'This account has been banned.', 'error');
                 return;
            }
            mainScreen.classList.remove('visible');
            document.getElementById('taskScreen').classList.add('visible');

            // Load tasks from server and render them
            const tasks = await fetchTasks();
            renderTasksList(tasks);

            // Initialize and update local task-link progress
            loadTaskLinkProgressFromStorage();
            updateTaskLinkUI();

            // Clear currentTask selection
            currentTask = null;

            loadUserData();
        }

        function hideTask(){
            // Clear any running countdown when leaving the screen
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
                isProcessingTask = false;
                taskActionState = currentTask && currentTask.is_completed ? 'COMPLETED' : 'JOIN_OR_CLAIM'; // Reset state
                updateUI();
            }
            document.getElementById('taskScreen').classList.remove('visible');
            mainScreen.classList.add('visible');
        }

        // Renamed and modified the old completeTask function to use currentTask
        async function claimTaskReward(){
            // Find per-task button for currentTask if available
            const taskBtn = currentTask ? document.querySelector(`button[data-task-id="${currentTask.id}"]`) : null;

            if (isBanned) {
                 showCustomAlert('Access Denied!', 'This account has been banned.', 'error');
                 return;
            }
            if (isProcessingTask) return; 
            if (!currentTask) {
                showCustomAlert('No Task Selected', 'Please select a task from the list first.', 'warning');
                return;
            }

            // Lock the per-task button to avoid rapid double-submits
            if (taskBtn) {
                taskBtn.dataset.locked = '1';
                taskBtn.disabled = true;
            }

            isProcessingTask = true;
            updateUI(); 

            const countdownTime = 5; 
            let countdown = countdownTime; 
            
            // Start the countdown on the button text (use per-task button if present)
            if (taskBtn) taskBtn.textContent = countdown;
            
            countdownInterval = setInterval(() => {
                countdown--;
                if (countdown >= 0) {
                    if (taskBtn) taskBtn.textContent = countdown;
                    if(countdownTime - countdown > 1){ // Only show alert after 1 second delay
                        // Show the processing alert (PENCIL STYLE)
                         showCustomAlert('Verifying Membership...', `Please wait ${countdown} seconds for channel membership verification.`, 'warning');
                    }
                } else {
                    // Stop the timer
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    if (taskBtn) taskBtn.textContent = 'Verifying...';
                    showCustomAlert('Verifying...', 'Contacting server to confirm membership and claim reward.', 'warning');

                    // Proceed to server verification
                    verifyAndClaim();
                }
            }, 1000);
            
        }

        async function verifyAndClaim() {
            // Find per-task button for currentTask if available
            const taskBtn = currentTask ? document.querySelector(`button[data-task-id="${currentTask.id}"]`) : null;

            if (!currentTask) {
                isProcessingTask = false;
                showCustomAlert('No Task Selected', 'Select a task before claiming.', 'warning');
                if (taskBtn) {
                    taskBtn.dataset.locked = '0';
                    taskBtn.disabled = false;
                }
                return;
            }

            const taskId = currentTask.id;

            // 1. Request Action ID from the Server (action_type must match server expectation)
            const actionId = await requestActionId(`completeTask_${taskId}`);
            if (!actionId) {
                isProcessingTask = false;
                taskActionState = 'JOIN_OR_CLAIM'; // Reset state on error
                if (taskBtn) {
                    taskBtn.dataset.locked = '0';
                    taskBtn.disabled = false;
                }
                updateUI();
                return;
            }

            // 2. Send completeTask request to the server - include task_id
            const result = await fetchApi({
                type: 'completeTask',
                action_id: actionId,
                task_id: taskId
            });
            
            isProcessingTask = false; // Reset flag

            if (result.ok) {
                // Update state
                updateState({ 
                    balance: result.data.new_balance
                });

                // Mark currentTask as completed locally
                if (currentTask) currentTask.is_completed = true;

                // Remove task card from DOM so it disappears for the user immediately
                const el = document.querySelector(`div[data-task-id="${taskId}"]`);
                if (el) el.remove();

                // Optionally refresh tasks from server (keeps UI consistent)
                const tasks = await fetchTasks();
                renderTasksList(tasks);

                // Show success alert
                showCustomAlert('Reward Claimed!', `You received ${result.data.actual_reward || currentTask.reward} SHIB for completing the task!`, 'success');
                
            } else {
                // On error, reload user data and tasks so UI is consistent
                await loadUserData();
                const tasks = await fetchTasks();
                renderTasksList(tasks);
                taskActionState = 'JOIN_OR_CLAIM'; // Force restart the process
                if (taskBtn) taskBtn.textContent = 'Open';
            }

            // Release the per-task button lock (success or failure)
            if (taskBtn) {
                taskBtn.dataset.locked = '0';
                taskBtn.disabled = false;
            }

            updateUI();
        }

        // handleTaskAction left in place but no longer required for fallback button
        function handleTaskAction() {
            const taskBtn = document.getElementById('taskActionBtn');

            if (!currentTask) {
                showCustomAlert('No Task Selected', 'Please choose a task from the list first.', 'warning');
                return;
            }
            
            if (currentTask.is_completed) {
                showCustomAlert('Task Completed!', 'Reward already claimed for this task.', 'warning');
                return;
            }
            
            if (isProcessingTask) return; // Prevent double clicking during claim process
            
            const channelLink = currentTask.link || '';

            if (taskActionState === 'JOIN_OR_CLAIM') {
                // This function may not be used now since per-task buttons manage flow
                if (channelLink && typeof Telegram.WebApp.openTelegramLink === 'function') {
                     Telegram.WebApp.openTelegramLink(channelLink);
                } else if (channelLink) {
                     window.open(channelLink, '_blank');
                } else {
                     showCustomAlert('No Link', 'This task has no join link. Click Claim to verify.', 'warning');
                }
                
                setTimeout(() => {
                    taskActionState = 'CLAIM'; 
                    if (taskBtn) {
                        taskBtn.disabled = false;
                        taskBtn.textContent = 'Claim';
                    }
                    showCustomAlert('Action Required', 'Please ensure you joined the channel. Click the button again to start the reward verification.', 'warning');
                }, 1500);


            } else if (taskActionState === 'CLAIM') {
                // Start the claim flow
                claimTaskReward();
            }
        }

        /* ===== Invite Screen Functions (No changes needed) ===== */
        
        function inviteFriends() {
            if (isBanned) {
                 // English translation of the Arabic alert message
                 showCustomAlert('Access Denied!', 'This account has been banned.', 'error');
                 return;
            }
            mainScreen.classList.remove('visible');
            document.getElementById('inviteScreen').classList.add('visible');
            generateReferralLink();
            loadUserData();
        }

        function hideInvite(){
            document.getElementById('inviteScreen').classList.remove('visible');
            mainScreen.classList.add('visible');
        }
        
        function generateReferralLink() {
            const referralLinkInput = document.getElementById('referralLinkInput');
            
            if (!tgUser) {
                referralLinkInput.value = 'User data not available.';
                return;
            }
            
            const userId = tgUser.id;
            const botPath = "Bot_ad_watchbot/earn"; 
            const inviteLink = `https://t.me/${botPath}?startapp=ref_${userId}`;
            
            referralLinkInput.value = inviteLink;
        }

        function copyReferralLink() {
            const inviteLink = document.getElementById('referralLinkInput').value;
            
            if (inviteLink === 'User data not available.' || inviteLink === 'Generating Link...') {
                // English translation of the Arabic alert message
                showCustomAlert('Error!', 'The referral link is not ready yet. Please wait a moment.', 'warning');
                return;
            }

            navigator.clipboard.writeText(inviteLink).then(() => {
                Telegram.WebApp.HapticFeedback.notificationOccurred('success');
                // English translation of the Arabic alert message
                showCustomAlert('Link Copied!', 'The referral link has been copied to the clipboard.', 'success');
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                // English translation of the Arabic alert message
                showCustomAlert('Copy Failed!', 'Failed to copy the link. Please try again.', 'error');
            });
        }
        /* ===== End of Invite Screen Functions ===== */


        /* ===== Spin Wheel (Wheel Code) (Modified to show two ads before spin and nicer effect) ===== */
        const colors = ['#00bfff', '#ff8c00', '#28a745', '#ff4500', '#00f2fe'];
        const prizeValues = sectors; 
        const canvas = document.getElementById('wheelCanvas');
        const ctx = canvas.getContext('2d');
        const spinResult = document.getElementById('spinResult');
        const spinBtn    = document.getElementById('spinBtn'); 
        let spinning = false;
        let currentAngle = 0;

        function drawWheel() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 130;
            const sectorCount = sectors.length;
            const arc = 2 * Math.PI / sectorCount;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.font = '24px Vazirmatn, sans-serif'; // Set font size for emoji
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';


            sectors.forEach((val, i) => {
                const start = i * arc - Math.PI / 2; 
                const end = start + arc;

                // Draw sector background
                ctx.beginPath();
                ctx.fillStyle = colors[i % colors.length];
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, start, end);
                ctx.closePath();
                ctx.fill();

                // Draw sector border
                ctx.beginPath();
                ctx.strokeStyle = '#fff'; 
                ctx.lineWidth = 3;
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, start, end);
                ctx.closePath();
                ctx.stroke();

                // üê± Add Emoji to the sector
                // Calculate the position for the emoji (midpoint of the arc, halfway to the edge)
                const angle = start + arc / 2;
                const textX = centerX + radius * 0.65 * Math.cos(angle);
                const textY = centerY + radius * 0.65 * Math.sin(angle);

                // Rotate context to align the emoji with the sector
                ctx.save();
                ctx.translate(textX, textY);
                ctx.rotate(angle + Math.PI / 2); // Rotate to be perpendicular to the radius
                ctx.fillStyle = '#000'; // Color doesn't matter for emoji usually
                ctx.fillText('üê±', 0, 0); 
                ctx.restore();
            });

            // Draw Center Circle
            ctx.beginPath();
            ctx.fillStyle = '#fff';
            ctx.arc(centerX, centerY, 20, 0, 2 * Math.PI); 
            ctx.fill();
            ctx.strokeStyle = '#ff3366';
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // Draw Mini Circle inside
            ctx.beginPath();
            ctx.fillStyle = '#ff3366';
            ctx.arc(centerX, centerY, 8, 0, 2 * Math.PI); 
            ctx.fill();
            ctx.shadowColor = 'transparent';
        }
        drawWheel();

        async function startSpin(){
            if(spinning) return;
            
            if (isBanned) {
                 // English translation of the Arabic alert message
                 showCustomAlert('Access Denied!', 'This account has been banned.', 'error');
                 return;
            }
            
            if (spinsToday >= DAILY_MAX_SPINS) {
                return;
            }
            
            // 1. Request Action ID from the Server for pre-spin (security check)
            const preSpinActionId = await requestActionId('preSpin');
            if (!preSpinActionId) return; // Error message already shown by fetchApi


            // 2. Request pre-spin registration (Server checks for banned user and consumes the action ID)
            const preSpinReqResult = await fetchApi({ 
                type: 'preSpin',
                action_id: preSpinActionId // ‚¨ÖÔ∏è Send Action ID
            });

            if (!preSpinReqResult.ok) {
                await loadUserData(); 
                return; 
            }
            
            // 3. Request Action ID from the Server for the spin result (prize confirmation)
            const spinResultActionId = await requestActionId('spinResult');
            if (!spinResultActionId) {
                // English translation of the Arabic alert message
                showCustomAlert('Security Error!', 'Failed to get confirmation token. Please try again.', 'error');
                await loadUserData(); 
                return;
            }
            
            // 4. Call Ad SDK twice in sequence (no intermediate alerts) - user will see two ads like watchAds
            show_10245709()
                .then(() => {
                    return show_10245709();
                })
                .then(async () => {
                    // Start spinning visual
                    spinning = true;
                    spinBtn.disabled = true;
                    spinResult.textContent = 'Spinning...'; 
                    canvas.classList.add('spinning');

                    // 5. Request spin result and prize addition (Server runs limits, Rate Limit, and validates Action ID)
                    const spinResultRes = await fetchApi({ 
                        type: 'spinResult',
                        action_id: spinResultActionId // ‚¨ÖÔ∏è Send Action ID
                    });
                    
                    if (spinResultRes.ok) {
                        const finalPrize = spinResultRes.data.actual_prize; 
                        const prizeIndex = spinResultRes.data.prize_index !== undefined ? spinResultRes.data.prize_index : 0; 
                        
                        const sectorCount = sectors.length; 
                        const arc = 2 * Math.PI / sectorCount; 
                        
                        const winningAngle = prizeIndex * arc + arc / 2; 
                        
                        let rotationToApply = Math.PI / 2 - winningAngle;
                        
                        rotationToApply = rotationToApply + (5 * 2 * Math.PI); 
                        
                        currentAngle += rotationToApply;

                        // Ensure transition is applied and trigger layout so animation runs reliably
                        canvas.style.transition = 'transform 4s cubic-bezier(0.22,0,0.2,1)';
                        requestAnimationFrame(() => {
                            canvas.style.transform = `rotate(${currentAngle}rad)`;
                        });
                        
                        setTimeout(async ()=>{
                            // After animation completes, clear inline transition so future changes use CSS default
                            canvas.style.transition = '';
                            canvas.classList.remove('spinning');
                            
                            // 6. Update balance and spin count with trusted server values 
                            updateState({ 
                                balance: spinResultRes.data.new_balance,
                                spins_today: spinResultRes.data.new_spins_count
                            });
                            
                            spinResult.textContent = `üéâ\n\nYou won ${finalPrize} SHIB!`;
                            // English translation of the Arabic alert message
                            showCustomAlert('Congratulations!', `You won ${finalPrize} SHIB!`, 'success');
                            
                            await loadUserData(); 
                            
                        },4000); 

                    } else {
                        canvas.classList.remove('spinning');
                        spinResult.textContent = `‚ùå ERROR ‚ùå\n\n[STATUS] Error receiving prize. Please try again.`;
                        // Custom Alert for spin result error is handled by fetchApi, but we ensure it here too:
                        if (!spinResultRes.error.includes('SECURITY ERROR')) { 
                            // English translation of the Arabic alert message
                            showCustomAlert('Error!', 'Error receiving prize. Please try again.', 'error');
                        }
                        await loadUserData(); 
                    }
                    
                    spinning   = false;
                    updateUI(); 
                })
                .catch(e => {
                    console.error("libtl.com Ad failed to show or was dismissed:", e);
                    // Ad error/cancellation handling
                    if (typeof e === 'string' && e.includes('canceled')) {
                        // English translation of the Arabic alert message
                        showCustomAlert('Ad Cancelled/Failed!', 'The ad was not watched completely. The attempt was not counted.', 'warning');
                    } else {
                        // English translation of the Arabic alert message
                        showCustomAlert('Ad Load Failed!', 'Ad failed to load. The attempt was not counted. Please try again.', 'error');
                    }
                    loadUserData(); 
                });
        }

        /* ===== Navigation and Withdraw (No changes needed) ===== */
        function showSpin(){
            if (isBanned) {
                 // English translation of the Arabic alert message
                 showCustomAlert('Access Denied!', 'This account has been banned.', 'error');
                 return;
            }
            mainScreen.classList.remove('visible');
            document.getElementById('spinScreen').classList.add('visible');
            loadUserData();
            updateUI(); 
        }
        function hideSpin(){
            document.getElementById('spinScreen').classList.remove('visible');
            mainScreen.classList.add('visible');
        }
        
        function showWithdraw(){
            if (isBanned) {
                 // English translation of the Arabic alert message
                 showCustomAlert('Access Denied!', 'This account has been banned.', 'error');
                 return;
            }
            mainScreen.classList.remove('visible');
            document.getElementById('withdrawScreen').classList.add('visible');
            loadUserData();
            displayWithdrawals(); 
        }
        
        function hideWithdraw(){
            document.getElementById('withdrawScreen').classList.remove('visible');
            mainScreen.classList.add('visible');
        }
        
        function displayWithdrawals() {
            const container = document.getElementById('withdrawalHistoryContainer');
            if (!withdrawalHistory || withdrawalHistory.length === 0) {
                // English translation of the Arabic alert message
                container.innerHTML = '<div class="no-records">No withdrawal requests currently.</div>';
                return;
            }

            let tableHTML = '<table class="history-table">';
            // English translation of the Arabic alert message
            tableHTML += '<thead><tr><th>Date</th><th>Amount (SHIB)</th><th>Status</th></tr></thead>';
            tableHTML += '<tbody>';

            withdrawalHistory.forEach(record => {
                // English translation of the Arabic alert message
                const statusText = record.status === 'pending' ? 'Pending' : 'Completed';
                const statusClass = record.status === 'pending' ? 'status-pending' : 'status-completed';
                tableHTML += `
                    <tr>
                        <td>${record.date}</td>
                        <td>${record.amount.toLocaleString()}</td>
                        <td><span class="${statusClass}">${statusText}</span></td>
                    </tr>
                `;
            });

            tableHTML += '</tbody></table>';
            container.innerHTML = tableHTML;
        }

        async function confirmWithdraw(){
            if (isBanned) {
                 // English translation of the Arabic alert message
                 showCustomAlert('Access Denied!', 'This account has been banned.', 'error');
                 return;
            }
            
            const binanceId = document.getElementById('binanceId').value.trim();
            const amount = parseInt(document.getElementById('withdrawAmount').value);
            
            if(!binanceId || binanceId.length < 8){ 
                // English translation of the Arabic alert message
                showCustomAlert('Invalid Input!', 'Please enter a valid Binance User ID (minimum 8 digits).', 'warning'); 
                return; 
            }
            if(isNaN(amount) || amount < 2000){ 
                // English translation of the Arabic alert message
                showCustomAlert('Invalid Amount!', 'The minimum withdrawal amount is 2000 SHIB.', 'warning'); 
                return; 
            }
            if(amount > shibBalance){ 
                // English translation of the Arabic alert message
                showCustomAlert('Balance Error!', `Your balance is insufficient. Your current balance is ${shibBalance.toLocaleString()} SHIB.`, 'error'); 
                return; 
            }
            
            // 1. Request Action ID from the Server ‚¨ÖÔ∏è ÿ™ŸÖ ÿßŸÑÿ™ŸÅÿπŸäŸÑ ÿπŸÑŸâ Withdraw
            const actionId = await requestActionId('withdraw');
            if (!actionId) return;

            // 2. Send withdrawal request via API
            const result = await fetchApi({
                type: 'withdraw',
                binanceId: binanceId,
                amount: amount,
                action_id: actionId // ‚¨ÖÔ∏è ÿ•ÿ±ÿ≥ÿßŸÑ Action ID
            });

            if (result.ok) {
                // 3. Update balance with trusted server value
                updateState({ balance: result.data.new_balance });
                
                // 4. Reload withdrawal history with new data
                await loadUserData(); 
                displayWithdrawals(); 
                
                // English translation of the Arabic alert message
                showCustomAlert('Request Sent!', `Details:\nBinance ID: ${binanceId}\nAmount: ${amount.toLocaleString()} SHIB\n\nThe transfer will be processed within 24 hours.`, 'success');
            }
        }
        
        // Final event listener to ensure background audio starts on the first user interaction
        document.addEventListener('click', function handler() {
            playBGAudio();
            document.removeEventListener('click', handler); // Remove after first successful click
        });
    </script>
</body>
</html>